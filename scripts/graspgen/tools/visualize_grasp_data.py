# SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/env python3
# Visualization tool for grasp data from YAML and JSON files.
#
# This tool provides a clean, user-friendly interface for visualizing grasp data
# generated by the grasp generation process. It uses meshcat for web-based 3D
# visualization and supports multiple grasp datasets with grid-based layout.
#
# Usage:
#     python visualize_grasp_data.py --grasp-paths grasp_data/ --object-root objects/
#     python visualize_grasp_data.py --grasp-paths grasp_data/ --max-grasps 50
#     python visualize_grasp_data.py --grasp-paths grasp_data/ --draw-normals --draw-edges

import argparse
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any

import numpy as np
import trimesh
import yaml
import json

try:
    import meshcat
    import meshcat.geometry as mcg
except ImportError as e:
    print(f"Error: Missing required dependencies: {e}")
    print("Please install: pip install meshcat")
    sys.exit(1)

def rgb2hex(rgb):
    """
    Converts rgb color to hex

    Args:
        rgb: color in rgb, e.g. (255,0,0)
    """
    return "0x%02x%02x%02x" % (rgb)

def generate_color_from_string(name: str) -> List[float]:
    """Generate a consistent color from a string.
    
    Args:
        name: String to generate color from
        
    Returns:
        RGB color as [r, g, b] values in [0, 1]
    """
    # Simple hash-based color generation
    hash_val = hash(name)
    r = ((hash_val >> 0) & 0xFF) / 255.0
    g = ((hash_val >> 8) & 0xFF) / 255.0
    b = ((hash_val >> 16) & 0xFF) / 255.0
    
    # Ensure colors are vibrant by adjusting saturation and lightness
    max_val = max(r, g, b)
    if max_val < 0.5:
        # Brighten dark colors
        r = r * 0.5 + 0.5
        g = g * 0.5 + 0.5
        b = b * 0.5 + 0.5
    
    return [r, g, b]


def normalize_vector(v: np.ndarray) -> np.ndarray:
    """Normalize a vector, handling zero vectors.
    
    Args:
        v: Input vector
        
    Returns:
        Normalized vector
    """
    norm = np.linalg.norm(v)
    if norm == 0:
        norm = np.finfo(v.dtype).eps
    return v / norm


class GraspDataVisualizer:
    """Main visualization class for grasp data from YAML files."""

    def __init__(self, 
                 show_normals: bool = False, 
                 show_edges: bool = False,
                 show_grasps: bool = True,
                 gripper_name: str = "onrobot_rg6",
                 use_json_transforms: bool = False):
        """Initialize the visualizer.

        Args:
            show_normals: Whether to draw normal vectors for meshes
            show_edges: Whether to draw mesh edges
            show_grasps: Whether to draw grasp poses
            gripper_name: Name of the gripper type for visualization
            use_json_transforms: Whether to use JSON transforms when loading YAML files
        """
        self.show_normals = show_normals
        self.show_edges = show_edges
        self.show_grasps = show_grasps
        self.gripper_name = gripper_name
        self.use_json_transforms = use_json_transforms
        self.vis = None

    def create_visualizer(self) -> meshcat.Visualizer:
        """Create and return a meshcat visualizer instance."""
        if self.vis is None:
            self.vis = meshcat.Visualizer()
            self.vis.delete()
        return self.vis

    def get_normal(self, transform: np.ndarray, approach_axis: int = 2) -> List[float]:
        """Get the normal vector from transform matrix (same as original script)."""
        return [row[approach_axis] for row in transform[:3]]
    
    def normal_color(self, n: List[float]) -> List[float]:
        """Generate color based on normal direction (same as original script)."""
        return [0.5 + 0.5*n[0], 0.5 + 0.5*n[1], 0.5 + 0.5*n[2]]

    def isaac_grasp_format_to_transforms(self, isaac_grasp_data):
        """Extract transforms and confidences from grasp data (same as original script)."""
        grasps = isaac_grasp_data
        confidences = [g['confidence'] for _, g in grasps.items()]

        positions = [trimesh.transformations.translation_matrix(g['position']) for _, g in grasps.items()]
        rotations = [trimesh.transformations.quaternion_matrix([g['orientation']['w']] + g['orientation']['xyz']) for _, g in grasps.items()]
        grasps = [p @ r for p, r in zip(positions, rotations)]

        assert len(grasps) == len(confidences)

        grasps = np.array(grasps)
        confidences = np.array(confidences)
        return grasps, confidences

    def isaac_grasp_get_render_points(self, isaac_grasp_data):
        """Get render points for gripper visualization (same as original script)."""
        grasps = isaac_grasp_data["grasps"]
        render_points = []
        base_point = [0.0, 0.0, 0.0]
        base_point[isaac_grasp_data["approach_axis"]] = isaac_grasp_data["base_length"]

        for _, g in grasps.items():
            bite_point = g['bite_point']
            render_points.append([base_point, bite_point])

        return render_points

    def load_gripper_from_npz(self, gripper_file_name: str):
        """Load gripper from existing .npz file using Gripper.load with config validation skipped.
        
        Args:
            gripper_file_name: Path to gripper USD file (e.g., "bots/robotiq_2f_85.usd")
            
        Returns:
            Gripper instance or None if loading fails
            
        Raises:
            FileNotFoundError: If the .npz file doesn't exist
        """
        try:
            # Import gripper classes - use relative path from tools folder
            import sys
            import os
            current_dir = os.path.dirname(os.path.abspath(__file__))
            parent_dir = os.path.dirname(current_dir)
            sys.path.append(parent_dir)
            from gripper import Gripper, GripperConfig
            
            # Convert USD path to .npz path
            npz_path = os.path.splitext(gripper_file_name)[0] + '.npz'
            
            if not os.path.exists(npz_path):
                raise FileNotFoundError(f"Gripper .npz file not found: {npz_path}. Please create it first using create_gripper_lab.py")
            
            # Create a minimal config just for the Gripper constructor
            gripper_config = GripperConfig(
                gripper_file=gripper_file_name,
                finger_colliders=["right_inner_finger", "left_inner_finger"],  # Default
                base_frame="base_link",  # Default
                bite=0.01,  # Default
                pinch_width_resolution=8,  # Default
                open_configuration={},  # Default
                device="cpu"  # Default
            )
            
            # Load gripper with config validation skipped
            gripper = Gripper.load(gripper_config, skip_config_validation=True)
            
            if gripper is None:
                raise FileNotFoundError(f"Failed to load gripper from {npz_path}")
            
            return gripper
            
        except Exception as e:
            print(f"Error loading gripper from {gripper_file_name}: {e}")
            raise

    def graspgen_json_to_transforms(self, json_data):
        """Extract transforms and confidences from graspgen JSON format."""
        grasps = json_data['grasps']
        transforms_list = grasps['transforms']
        object_in_gripper = grasps['object_in_gripper']
        
        # Convert list of 4x4 matrices to numpy array
        transforms = np.array(transforms_list)
        
        # Convert boolean success flags to confidence scores
        # Use 1.0 for successful grasps, 0.0 for failed grasps
        confidences = np.array([1.0 if success else 0.0 for success in object_in_gripper])
        
        return transforms, confidences

    def graspgen_json_get_render_points(self, json_data, gripper):
        """Get render points for gripper visualization from JSON format.
        
        Creates base_point and bite_point pairs for Y-shaped gripper visualization.
        Uses gripper parameters from loaded Gripper class.
        """
        grasps = json_data['grasps']
        transforms_list = grasps['transforms']
        render_points = []
        base_point = [0.0, 0.0, 0.0]
        base_point[gripper.approach_axis] = gripper.base_length
        bite_point = np.abs(gripper.bite_point).tolist()

        for _ in transforms_list:
            render_points.append([base_point, bite_point])
        
        
        return render_points

    def load_object_mesh(self, object_mesh_path: str, object_scale: float) -> trimesh.Trimesh:
        """Load and scale an object mesh from file.
        
        Args:
            object_mesh_path: Path to the object mesh file
            object_scale: Scale factor to apply to the mesh
            
        Returns:
            Loaded and scaled trimesh object
            
        Raises:
            FileNotFoundError: If the mesh file doesn't exist
            RuntimeError: If the mesh file cannot be loaded
        """
        if not os.path.exists(object_mesh_path):
            raise FileNotFoundError(f"Object mesh file not found: {object_mesh_path}")
        
        # Load object mesh
        if object_mesh_path.lower().endswith(('.usd', '.usda', '.usdc')):
            # Load USD file using the existing converter
            try:
                import sys
                sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
                from usd_to_obj_converter import extract_mesh_from_usd
                object_mesh = extract_mesh_from_usd(object_mesh_path)
                if object_mesh is None:
                    raise RuntimeError(f"Failed to extract mesh from USD file: {object_mesh_path}")
            except ImportError:
                # Fallback: try to load with trimesh directly
                try:
                    object_mesh = trimesh.load(object_mesh_path, validate=True)
                except Exception as e:
                    raise RuntimeError(f"Failed to load USD file {object_mesh_path}: {e}")
        else:
            # Load OBJ/STL files normally
            object_mesh = trimesh.load(object_mesh_path, validate=True)
        
        # Apply scale
        object_mesh.apply_scale(object_scale)
        
        return object_mesh

    def load_grasp_data(self, file_path: str, object_root: str) -> Dict[str, Any]:
        """Load grasp data from a YAML or JSON file.
        
        Args:
            file_path: Path to YAML or JSON file containing grasp data
            object_root: Root directory for object mesh files
            
        Returns:
            Dictionary containing grasp data and metadata
        """
        file_path_obj = Path(file_path)
        
        # Determine file type and load accordingly
        if file_path_obj.suffix.lower() == '.json':
            return self.load_json_grasp_data(file_path, object_root)
        else:
            return self.load_yaml_grasp_data(file_path, object_root)

    def load_yaml_grasp_data(self, yaml_path: str, object_root: str) -> Dict[str, Any]:
        """Load grasp data from a YAML file using the exact same logic as the original script.
        
        Args:
            yaml_path: Path to YAML file containing grasp data
            object_root: Root directory for object mesh files
            
        Returns:
            Dictionary containing grasp data and metadata
        """
        with open(yaml_path, "r") as f:
            data = yaml.safe_load(f)
        
        # Extract object mesh file path (same as original script)
        if 'client_obj_file' in data:
            object_mesh_file = data['client_obj_file']
        else:
            object_mesh_file = data['object_file']
        
        # Handle USD files directly or convert to OBJ if needed
        object_mesh_path = os.path.join(object_root, object_mesh_file)
        
        # Load and scale object mesh
        scale = data.get('object_scale', 0.025)  # Default from original script
        object_mesh = self.load_object_mesh(object_mesh_path, scale)
        
        # Extract gripper name from YAML
        gripper_file = data.get('gripper_file', 'bots/robotiq_2f_85.usd')
        gripper_name = os.path.splitext(os.path.basename(gripper_file))[0]  # Extract name from file path
        
        # Check if corresponding JSON file exists and use its transforms
        json_path = os.path.splitext(yaml_path)[0] + '.json'
        if os.path.exists(json_path) and self.use_json_transforms:
            print(f"Found corresponding JSON file: {json_path}")
            print("Using JSON transforms with YAML gripper data for comparison")
            
            # Load JSON file to get transforms
            with open(json_path, "r") as f:
                json_data = json.load(f)
            
            # Extract transforms from JSON
            transforms, confidences = self.graspgen_json_to_transforms(json_data)
            
        else:
            # Use normal YAML processing
            transforms, confidences = self.isaac_grasp_format_to_transforms(data['grasps'])
            
        render_points = self.isaac_grasp_get_render_points(data)
        
        return {
            'mesh': object_mesh,
            'transforms': transforms,
            'confidences': confidences,
            'render_points': render_points,
            'approach_axis': data.get('approach_axis', 2),
            'base_length': data.get('base_length', 0.1),
            'gripper_name': gripper_name,
            'data_path': yaml_path
        }

    def load_json_grasp_data(self, json_path: str, object_root: str) -> Dict[str, Any]:
        """Load grasp data from a JSON file in graspgen format.
        
        Args:
            json_path: Path to JSON file containing grasp data
            object_root: Root directory for object mesh files
            
        Returns:
            Dictionary containing grasp data and metadata
        """
        with open(json_path, "r") as f:
            data = json.load(f)
        
        # Extract object information from JSON format
        object_info = data['object']
        object_mesh_file = object_info['file']
        object_scale = object_info['scale']
        
        # Construct full path to object mesh
        object_mesh_path = os.path.join(object_root, object_mesh_file)
        
        # Load and scale object mesh
        object_mesh = self.load_object_mesh(object_mesh_path, object_scale)
        
        # Load gripper from .npz file
        gripper_info = data.get('gripper', {})
        gripper_file_name = gripper_info.get('file_name', 'bots/robotiq_2f_85.usd')
        gripper_name = gripper_info.get('name', 'robotiq_2f_85')  # Extract gripper name
        gripper = self.load_gripper_from_npz(gripper_file_name)
        
        # Extract grasp data using JSON-specific functions
        try:
            transforms, confidences = self.graspgen_json_to_transforms(data)
            render_points = self.graspgen_json_get_render_points(data, gripper)
        except Exception as e:
            print(f"Error processing JSON grasp data: {e}")
            raise
        
        return {
            'mesh': object_mesh,
            'transforms': transforms,
            'confidences': confidences,
            'render_points': render_points,
            'approach_axis': gripper.approach_axis if gripper else 2,  # Default approach axis
            'base_length': gripper.base_length if gripper else 0.1,  # Default base length
            'gripper_name': gripper_name,
            'data_path': json_path,
        }

    def visualize_mesh(self, vis: meshcat.Visualizer, name: str, 
                      mesh: trimesh.Trimesh,
                       color: Optional[List[float]] = None, 
                       transform: Optional[np.ndarray] = None):
        """Visualize a single mesh in meshcat.

        Args:
            vis: Meshcat visualizer instance
            name: Name for the mesh in the visualizer
            mesh: Trimesh object to visualize
            color: RGB color as [r, g, b] values in [0, 1]
            transform: 4x4 transformation matrix
        """
        if color is None:
            color = [0.7, 0.7, 0.7]  # Default gray

        # Apply transform if provided
        mesh_copy = mesh.copy()
        if transform is not None:
            mesh_copy.apply_transform(transform)

        # Create meshcat geometry
        geometry = mcg.TriangularMeshGeometry(
            vertices=mesh_copy.vertices,
            faces=mesh_copy.faces
        )

        # Create material with color
        material = mcg.MeshLambertMaterial(
            color=int(color[0] * 255) << 16 | int(color[1] * 255) << 8 | int(color[2] * 255)
        )

        # Set object in visualizer
        vis[name].set_object(geometry, material)

    def visualize_normals(self, vis: meshcat.Visualizer, name: str, 
                          mesh: trimesh.Trimesh, length: float = 0.01):
        """Visualize mesh face normals as line segments.

        Args:
            vis: Meshcat visualizer instance
            name: Name for the normals in the visualizer
            mesh: Trimesh object to compute normals for
            length: Length of normal vectors
        """
        positions = []
        colors = []

        # Get face centers and normals
        face_centers = mesh.triangles_center
        face_normals = mesh.face_normals

        for center, normal in zip(face_centers, face_normals):
            # Start and end points of normal vector
            start = center
            end = center + normal * length

            positions.extend([start, end])

            # Color based on normal direction (RGB = 0.5 + 0.5 * normal)
            color = [0.5 + 0.5 * normal[0], 0.5 + 0.5 * normal[1], 0.5 + 0.5 * normal[2]]
            colors.extend([color, color])

        # Create line segments
        vis[name].set_object(
            mcg.LineSegments(
                mcg.PointsGeometry(
                    position=np.array(positions).T.astype(np.float32),
                    color=np.array(colors).T.astype(np.float32)
                ),
                mcg.LineBasicMaterial(vertexColors=True)
            )
        )

    def visualize_edges(self, vis: meshcat.Visualizer, name: str, 
                        mesh: trimesh.Trimesh,
                        color: Optional[List[float]] = None):
        """Visualize mesh edges as line segments.

        Args:
            vis: Meshcat visualizer instance
            name: Name for the edges in the visualizer
            mesh: Trimesh object to visualize edges for
            color: RGB color as [r, g, b] values in [0, 1]
        """
        if color is None:
            color = [0.0, 0.0, 0.0]  # Default black

        positions = []

        # Create line segments for each triangle edge
        for face in mesh.faces:
            a, b, c = mesh.vertices[face]
            positions.extend([a, b, b, c, c, a])

        # Create uniform color array
        colors = [color] * len(positions)

        # Create line segments
        vis[name].set_object(
            mcg.LineSegments(
                mcg.PointsGeometry(
                    position=np.array(positions).T.astype(np.float32),
                    color=np.array(colors).T.astype(np.float32)
                ),
                mcg.LineBasicMaterial(vertexColors=True)
            )
        )

    def _visualize_grasp(self, vis: meshcat.Visualizer, name: str, transform: np.ndarray, color: List[float], grasp_vertices: List[np.ndarray], **kwargs):
        for i, grasp_vertex in enumerate(grasp_vertices):
            vis[name + f"/{i}"].set_object(
                mcg.Line(
                    mcg.PointsGeometry(grasp_vertex),
                    mcg.MeshBasicMaterial(color=rgb2hex(tuple(color)), **kwargs),
                )
            )
            vis[name].set_transform(transform.astype(np.float64))


    def visualize_grasp_pose(self, vis: meshcat.Visualizer, name: str,
                             transform: np.ndarray, confidence: float,
                             render_points: List[List[float]], approach_axis: int):
        """Visualize a grasp pose using the exact same logic as the original script."""
        # Get approach direction normal (same as original script)
        n = self.get_normal(transform, approach_axis)
        
        # Generate color based on approach direction (same as original script)
        color = self.normal_color(n)
        color = [int(255.0*color[0]), int(255.0*color[1]), int(255.0*color[2])]
        
        # Apply confidence-based color inversion for failed grasps (same as original script)
        THRESHOLD = 0.8
        if confidence <= THRESHOLD:
            color = [255-color[0], 255-color[1], 255-color[2]]
        
        # Create Y-shaped grasp vertices (exactly same as original script)
        grasp_vertices = np.zeros((7, 4))
        b = np.array(render_points[1])  # bite_point
        r = np.array(render_points[0])  # base_point
        
        # Create brp by zeroing out the component of bp that corresponds to largest magnitude in rp
        a = np.zeros(3)
        max_idx = np.argmax(np.abs(r))
        a[max_idx] = b[max_idx]
        d = a - b
        e = a - r
        c = b - e
        
        yp0 = b
        yp1 = c
        yp2 = r
        yp3 = np.array([0.0, 0.0, 0.0])
        yp4 = r
        yp5 = r + d
        yp6 = r + d + e
        
        # w is 1
        grasp_vertices[:, 3] = 1.0
        grasp_vertices[0, :3] = yp0
        grasp_vertices[1, :3] = yp1
        grasp_vertices[2, :3] = yp2
        grasp_vertices[3, :3] = yp3
        grasp_vertices[4, :3] = yp4
        grasp_vertices[5, :3] = yp5
        grasp_vertices[6, :3] = yp6
        
        # Convert to the format expected by meshcat_utils.visualize_grasp
        grasp_vertices = [grasp_vertices.transpose()]
        
        # Use local meshcat_utils.visualize_grasp for consistent visualization
        self._visualize_grasp(
            vis,
            name,
            transform,
            color=color,
            grasp_vertices=grasp_vertices,
            linewidth=1.0,
        )
    
    def visualize_grasp_dataset(self, grasp_data: Dict[str, Any], 
                                dataset_name: str, grid_position: Tuple[int, int],
                                grid_spacing: float = 0.5):
        """Visualize a single grasp dataset with grid positioning.
        
        Args:
            grasp_data: Dictionary containing grasp data
            dataset_name: Name for the dataset in the visualizer
            grid_position: (row, col) position in the grid
            grid_spacing: Spacing between grid elements
        """
        row, col = grid_position
        tx = col * grid_spacing
        ty = row * grid_spacing
        
        # Apply grid translation to mesh
        mesh = grasp_data['mesh'].copy()
        mesh.apply_translation([tx, ty, 0.0])
        
        # Generate color for this dataset
        color = generate_color_from_string(dataset_name)
        
        # Visualize the mesh
        self.visualize_mesh(self.vis, dataset_name, mesh, color)
        
        # Add normals if requested
        if self.show_normals and self.vis is not None:
            self.visualize_normals(self.vis, f"{dataset_name}/normals", mesh)
        
        # Add edges if requested
        if self.show_edges and self.vis is not None:
            self.visualize_edges(self.vis, f"{dataset_name}/edges", mesh)
        
        # Add grasps if requested
        if self.show_grasps and self.vis is not None:
            transforms = grasp_data['transforms']
            confidences = grasp_data['confidences']
            render_points = grasp_data.get('render_points', [])
            approach_axis = grasp_data.get('approach_axis', 2)
            
            num_pass = 0
            num_fail = 0
            
            for i, (transform, confidence) in enumerate(zip(transforms, confidences)):
                # Apply grid translation to grasp transform (same as original script)
                grasp_transform = transform.copy()
                grasp_transform[:3, 3] += [tx, ty, 0.0]
                
                # Categorize by confidence (same as original script)
                THRESHOLD = 0.8
                if confidence > THRESHOLD:
                    category = "pass"
                    num_pass += 1
                    num_out = num_pass
                else:
                    category = "fail"
                    num_fail += 1
                    num_out = num_fail
                
                grasp_name = f"{dataset_name}/grasps_{category}/{num_out}"
                
                # Get render points for this grasp (fallback to default if not available)
                if i < len(render_points):
                    rp = render_points[i]
                else:
                    # Default render points if not available
                    rp = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.05]]
                
                # Pass confidence and approach_axis for proper coloring (same as original script)
                self.visualize_grasp_pose(self.vis, grasp_name, grasp_transform, confidence, rp, approach_axis)
            
            print(f"  - Visualized {len(transforms)} grasps: pass/fail {num_pass}/{num_fail}")

    def visualize_grasp_data(self, grasp_paths: List[str], object_root: str,
                            max_grasps: Optional[int] = None):
        """Visualize multiple grasp datasets with grid layout.
        
        Args:
            grasp_paths: List of paths to YAML/JSON files containing grasp data
            object_root: Root directory for object mesh files
            max_grasps: Maximum number of grasps to visualize per dataset
        """
        if not grasp_paths:
            print("No grasp paths provided")
            return
        
        # Load all grasp datasets
        grasp_datasets = []
        for grasp_path in grasp_paths:
            try:
                print(f"Loading grasp data from: {grasp_path}")
                grasp_data = self.load_grasp_data(grasp_path, object_root)
                
                # Limit number of grasps if specified
                if max_grasps and len(grasp_data['transforms']) > max_grasps:
                    grasp_data['transforms'] = grasp_data['transforms'][:max_grasps]
                    grasp_data['confidences'] = grasp_data['confidences'][:max_grasps]
                    grasp_data['render_points'] = grasp_data['render_points'][:max_grasps]
                
                grasp_datasets.append(grasp_data)
                print(f"  Loaded {len(grasp_data['transforms'])} grasps")
                
            except Exception as e:
                print(f"Warning: Failed to load {grasp_path}: {e}")
                continue
        
        if not grasp_datasets:
            print("No valid grasp datasets loaded")
            return
        
        # Create visualizer
        self.vis = self.create_visualizer()
        print(f"Meshcat visualizer available at: {self.vis.url()}")
        
        # Calculate grid dimensions
        num_datasets = len(grasp_datasets)
        grid_cols = int(np.ceil(np.sqrt(num_datasets)))
        grid_rows = int(np.ceil(num_datasets / grid_cols))
        
        print(f"\nVisualizing {num_datasets} datasets in {grid_rows}x{grid_cols} grid:")
        
        # Visualize each dataset
        for i, grasp_data in enumerate(grasp_datasets):
            row = i // grid_cols
            col = i % grid_cols
            
            # Extract dataset name from file path (YAML or JSON)
            file_path = grasp_data.get('data_path')
            file_basename = os.path.splitext(os.path.basename(file_path))[0]
            
            # Extract distinguishing part from path
            path_parts = file_path.split('/')
            distinguishing_part = ""
            for part in path_parts:
                if any(keyword in part for keyword in ['guess', 'sim', 'cpu', 'cuda', 'ccd']):
                    distinguishing_part = part
                    break
            
            if distinguishing_part:
                dataset_name = f"{file_basename}_{distinguishing_part}"
            else:
                dataset_name = file_basename
            
            self.visualize_grasp_dataset(grasp_data, dataset_name, (row, col))
        
        print(f"\nVisualization complete. View at: {self.vis.url()}")
        
        try:
            # Keep the visualizer running
            input("Press Enter to exit...\n")
        except KeyboardInterrupt:
            print("\nExiting...")


def main():
    """Main entry point for the visualization tool."""
    parser = argparse.ArgumentParser(
        description="Visualize grasp data from YAML and JSON files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Visualize all YAML/JSON files in a directory
  python visualize_grasp_data.py --grasp-paths grasp_data/ --object-root objects/

  # Visualize specific files
  python visualize_grasp_data.py --grasp-paths file1.yaml file2.json --object-root objects/

  # Limit number of grasps per dataset
  python visualize_grasp_data.py --grasp-paths grasp_data/ --max-grasps 50

  # Include normals and edges
  python visualize_grasp_data.py --grasp-paths grasp_data/ --draw-normals --draw-edges

  # Custom object root path
  python visualize_grasp_data.py --grasp-paths grasp_data/ --object-root /path/to/objects/

  # Use JSON transforms with YAML files for comparison
  python visualize_grasp_data.py --grasp-paths file.yaml --use-json-transforms
        """
    )

    parser.add_argument(
        "--grasp-paths", "-p",
        nargs="+",
        required=True,
        help="Paths to YAML/JSON files containing grasp data or directories containing YAML/JSON files"
    )

    parser.add_argument(
        "--object-root", "-o",
        type=str,
        default="./",
        help="Root directory for object mesh files (default: ./)"
    )

    parser.add_argument(
        "--max-grasps",
        type=int,
        help="Maximum number of grasps to visualize per dataset"
    )

    parser.add_argument(
        "--draw-normals",
        action="store_true",
        help="Draw normal vectors for each mesh"
    )

    parser.add_argument(
        "--draw-edges",
        action="store_true",
        help="Draw edges for each mesh"
    )

    parser.add_argument(
        "--no-grasps",
        action="store_true",
        help="Disable grasp pose visualization"
    )

    parser.add_argument(
        "--gripper-name",
        type=str,
        default="onrobot_rg6",
        help="Name of the gripper type for visualization (default: onrobot_rg6)"
    )

    parser.add_argument(
        "--use-json-transforms",
        action="store_true",
        help="Use JSON transforms when loading YAML files (for comparison testing)"
    )

    args = parser.parse_args()

    # Expand directories to find YAML and JSON files
    grasp_files = []
    for path in args.grasp_paths:
        path_obj = Path(path)
        if path_obj.is_file() and (path.endswith('.yaml') or path.endswith('.json')):
            grasp_files.append(path)
        elif path_obj.is_dir():
            # Find all YAML and JSON files in directory and subdirectories
            for grasp_file in path_obj.rglob("*.yaml"):
                grasp_files.append(str(grasp_file))
            for grasp_file in path_obj.rglob("*.json"):
                grasp_files.append(str(grasp_file))
        else:
            print(f"Warning: {path} is not a valid YAML/JSON file or directory")

    if not grasp_files:
        print("Error: No YAML or JSON files found")
        sys.exit(1)

    print(f"Found {len(grasp_files)} grasp files:")
    for grasp_file in grasp_files:
        print(f"  - {grasp_file}")

    # Validate object root
    if not os.path.exists(args.object_root):
        print(f"Error: Object root directory does not exist: {args.object_root}")
        sys.exit(1)

    try:
        # Create visualizer and run
        visualizer = GraspDataVisualizer(
            show_normals=args.draw_normals,
            show_edges=args.draw_edges,
            show_grasps=not args.no_grasps,
            gripper_name=args.gripper_name,
            use_json_transforms=args.use_json_transforms
        )
        visualizer.visualize_grasp_data(grasp_files, args.object_root, args.max_grasps)

    except Exception as e:
        print(f"Error during visualization: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
