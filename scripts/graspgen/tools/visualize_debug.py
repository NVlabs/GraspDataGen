# SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/env python3
"""
Visualization tool for debug output from create_gripper_lab.py

This tool provides a clean, user-friendly interface for visualizing the OBJ/JSON
debug output generated by the gripper creation process. It uses meshcat for
web-based 3D visualization.

Usage:
    python visualize_debug.py --path debug_output/
    python visualize_debug.py --path debug_output/write_joint_state/
    python visualize_debug.py --path debug_output/ --draw-normals --draw-edges
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional

import numpy as np
import trimesh

try:
    import meshcat
    import meshcat.geometry as mcg
except ImportError as e:
    print(f"Error: Missing required dependencies: {e}")
    print("Please install: pip install meshcat")
    sys.exit(1)


def generate_color_from_string(name: str) -> List[float]:
    """Generate a consistent color from a string."""
    # Simple hash-based color generation
    hash_val = hash(name)
    r = ((hash_val >> 0) & 0xFF) / 255.0
    g = ((hash_val >> 8) & 0xFF) / 255.0
    b = ((hash_val >> 16) & 0xFF) / 255.0
    
    # Ensure colors are vibrant by adjusting saturation and lightness
    max_val = max(r, g, b)
    if max_val < 0.5:
        # Brighten dark colors
        r = r * 0.5 + 0.5
        g = g * 0.5 + 0.5
        b = b * 0.5 + 0.5
    
    return [r, g, b]


class DebugVisualizer:
    """Main visualization class for debug output from create_gripper_lab."""

    def __init__(self, show_normals: bool = False, show_edges: bool = False):
        """Initialize the visualizer.

        Args:
            show_normals: Whether to draw normal vectors for meshes
            show_edges: Whether to draw mesh edges
        """
        self.show_normals = show_normals
        self.show_edges = show_edges
        self.vis = None

    def create_visualizer(self) -> meshcat.Visualizer:
        """Create and return a meshcat visualizer instance."""
        if self.vis is None:
            self.vis = meshcat.Visualizer()
            self.vis.delete()
        return self.vis

    def load_debug_folder(self, folder_path: str) -> Dict[str, Dict]:
        """Load all OBJ/JSON pairs from a debug folder.

        Args:
            folder_path: Path to folder containing OBJ and JSON files

        Returns:
            Dictionary mapping mesh names to their data (mesh, transforms)
        """
        folder_path_obj = Path(folder_path)
        if not folder_path_obj.exists():
            raise FileNotFoundError(f"Debug folder not found: {folder_path}")

        debug_data = {}

        # Find all OBJ files
        obj_files = list(folder_path_obj.glob("*.obj"))
        if not obj_files:
            print(f"Warning: No OBJ files found in {folder_path}")
            return debug_data

        for obj_file in obj_files:
            mesh_name = obj_file.stem
            json_file = obj_file.with_suffix(".json")

            # Load mesh
            try:
                mesh = trimesh.load(str(obj_file), validate=True)
                if not isinstance(mesh, trimesh.Trimesh):
                    print(f"Warning: {obj_file} is not a valid mesh, skipping")
                    continue
            except Exception as e:
                print(f"Warning: Failed to load {obj_file}: {e}")
                continue

            # Load transforms
            transforms = [np.eye(4)]  # Default identity transform
            if json_file.exists():
                try:
                    with open(json_file, 'r') as f:
                        transform_data = json.load(f)
                        if isinstance(transform_data, list) and len(transform_data) > 0:
                            transforms = [np.array(t) for t in transform_data]
                except Exception as e:
                    print(f"Warning: Failed to load transforms from {json_file}: {e}")

            debug_data[mesh_name] = {
                'mesh': mesh,
                'transforms': transforms
            }

        return debug_data

    def visualize_mesh(self, vis: meshcat.Visualizer, name: str, mesh: trimesh.Trimesh,
                       color: Optional[List[float]] = None, transform: Optional[np.ndarray] = None):
        """Visualize a single mesh in meshcat.

        Args:
            vis: Meshcat visualizer instance
            name: Name for the mesh in the visualizer
            mesh: Trimesh object to visualize
            color: RGB color as [r, g, b] values in [0, 1]
            transform: 4x4 transformation matrix
        """
        if color is None:
            color = [0.7, 0.7, 0.7]  # Default gray

        # Apply transform if provided
        mesh_copy = mesh.copy()
        if transform is not None:
            mesh_copy.apply_transform(transform)

        # Create meshcat geometry
        geometry = mcg.TriangularMeshGeometry(
            vertices=mesh_copy.vertices,
            faces=mesh_copy.faces
        )

        # Create material with color
        material = mcg.MeshLambertMaterial(
            color=int(color[0] * 255) << 16 | int(color[1] * 255) << 8 | int(color[2] * 255)
        )

        # Set object in visualizer
        vis[name].set_object(geometry, material)

    def visualize_normals(self, vis: meshcat.Visualizer, name: str, mesh: trimesh.Trimesh,
                          length: float = 0.01):
        """Visualize mesh face normals as line segments.

        Args:
            vis: Meshcat visualizer instance
            name: Name for the normals in the visualizer
            mesh: Trimesh object to compute normals for
            length: Length of normal vectors
        """
        positions = []
        colors = []

        # Get face centers and normals
        face_centers = mesh.triangles_center
        face_normals = mesh.face_normals

        for center, normal in zip(face_centers, face_normals):
            # Start and end points of normal vector
            start = center
            end = center + normal * length

            positions.extend([start, end])

            # Color based on normal direction (RGB = 0.5 + 0.5 * normal)
            color = [0.5 + 0.5 * normal[0], 0.5 + 0.5 * normal[1], 0.5 + 0.5 * normal[2]]
            colors.extend([color, color])

        # Create line segments
        vis[name].set_object(
            mcg.LineSegments(
                mcg.PointsGeometry(
                    position=np.array(positions).T.astype(np.float32),
                    color=np.array(colors).T.astype(np.float32)
                ),
                mcg.LineBasicMaterial(vertexColors=True)
            )
        )

    def visualize_edges(self, vis: meshcat.Visualizer, name: str, mesh: trimesh.Trimesh,
                        color: Optional[List[float]] = None):
        """Visualize mesh edges as line segments.

        Args:
            vis: Meshcat visualizer instance
            name: Name for the edges in the visualizer
            mesh: Trimesh object to visualize edges for
            color: RGB color as [r, g, b] values in [0, 1]
        """
        if color is None:
            color = [0.0, 0.0, 0.0]  # Default black

        positions = []

        # Create line segments for each triangle edge
        for face in mesh.faces:
            a, b, c = mesh.vertices[face]
            positions.extend([a, b, b, c, c, a])

        # Create uniform color array
        colors = [color] * len(positions)

        # Create line segments
        vis[name].set_object(
            mcg.LineSegments(
                mcg.PointsGeometry(
                    position=np.array(positions).T.astype(np.float32),
                    color=np.array(colors).T.astype(np.float32)
                ),
                mcg.LineBasicMaterial(vertexColors=True)
            )
        )

    def visualize_debug_folder(self, folder_path: str, folder_name: Optional[str] = None):
        """Visualize all meshes from a debug folder.

        Args:
            folder_path: Path to debug folder
            folder_name: Optional name for grouping in visualizer
        """
        if folder_name is None:
            folder_name = Path(folder_path).name

        debug_data = self.load_debug_folder(folder_path)
        if not debug_data:
            print(f"No valid debug data found in {folder_path}")
            return

        vis = self.create_visualizer()

        # Generate a unique color for this folder
        folder_color = generate_color_from_string(folder_name)

        print(f"Visualizing folder: {folder_name}")
        for mesh_name, data in debug_data.items():
            mesh = data['mesh']
            transforms = data['transforms']

            for i, transform in enumerate(transforms):
                # Create unique name for this mesh instance
                instance_name = f"{folder_name}/{mesh_name}"
                if len(transforms) > 1:
                    instance_name += f"_{i}"

                # Visualize the mesh
                self.visualize_mesh(vis, instance_name, mesh, folder_color, transform)

                # Add normals if requested
                if self.show_normals:
                    mesh_copy = mesh.copy()
                    mesh_copy.apply_transform(transform)
                    self.visualize_normals(vis, f"{instance_name}/normals", mesh_copy)

                # Add edges if requested
                if self.show_edges:
                    mesh_copy = mesh.copy()
                    mesh_copy.apply_transform(transform)
                    self.visualize_edges(vis, f"{instance_name}/edges", mesh_copy)

            print(f"  - Visualized {mesh_name} with {len(transforms)} transform(s)")

    def visualize_debug_output(self, debug_path: str):
        """Visualize debug output from create_gripper_lab.

        Args:
            debug_path: Path to debug_output directory or specific folder
        """
        debug_path_obj = Path(debug_path)

        if not debug_path_obj.exists():
            raise FileNotFoundError(f"Debug path not found: {debug_path}")

        vis = self.create_visualizer()
        print(f"Meshcat visualizer available at: {vis.url()}")

        if debug_path_obj.is_file():
            raise ValueError("Expected directory path, got file path")

        # Check if this is a specific debug folder (contains .obj files)
        obj_files = list(debug_path_obj.glob("*.obj"))
        if obj_files:
            # This is a specific debug folder
            self.visualize_debug_folder(str(debug_path))
        else:
            # This is the parent debug_output directory, visualize all subfolders
            subfolders = [d for d in debug_path_obj.iterdir() if d.is_dir()]
            if not subfolders:
                print(f"No debug folders found in {debug_path}")
                return

            print(f"Found {len(subfolders)} debug folders:")
            for folder in sorted(subfolders):
                print(f"  - {folder.name}")
                self.visualize_debug_folder(str(folder), folder.name)

        print(f"\nVisualization complete. View at: {vis.url()}")

        try:
            # Keep the visualizer running
            input("Press Enter to exit...\n")
        except KeyboardInterrupt:
            print("\nExiting...")


def main():
    """Main entry point for the visualization tool."""
    parser = argparse.ArgumentParser(
        description="Visualize debug output from create_gripper_lab.py",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Visualize all debug folders
  python visualize_debug.py --path debug_output/

  # Visualize a specific debug folder
  python visualize_debug.py --path debug_output/write_joint_state/

  # Include normals and edges
  python visualize_debug.py --path debug_output/ --draw-normals --draw-edges

  # Visualize with custom path
  python visualize_debug.py --path /path/to/debug_output/
        """
    )

    parser.add_argument(
        "--path", "-p",
        type=str,
        default="debug_output/",
        help="Path to debug output directory or specific folder (default: debug_output/)"
    )

    parser.add_argument(
        "--draw-normals",
        action="store_true",
        help="Draw normal vectors for each mesh"
    )

    parser.add_argument(
        "--draw-edges",
        action="store_true",
        help="Draw edges for each mesh"
    )

    args = parser.parse_args()

    # Validate arguments
    if not os.path.exists(args.path):
        print(f"Error: Path does not exist: {args.path}")
        print("Make sure you have run create_gripper_lab.py with debug output enabled.")
        print("To enable debug output, uncomment the save_scene_full() calls in create_gripper_lab.py")
        sys.exit(1)

    try:
        # Create visualizer and run
        visualizer = DebugVisualizer(
            show_normals=args.draw_normals,
            show_edges=args.draw_edges
        )
        visualizer.visualize_debug_output(args.path)

    except Exception as e:
        print(f"Error during visualization: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
